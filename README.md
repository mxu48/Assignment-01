# Assignment-01 CS 245 Mina Xu
Documentation of findings as requested in assignment description - Requirement 3:
On Google Docs, pasted here:
[https://docs.google.com/document/d/1hJofZzJDxh6jWICuzV41rckEKz-ae-cqxEnUAGw1U64/edit?usp=sharing]

- Defend choice of in-place sorting algorithm:

I chose to use QuickSort as my in-place sorting algorithm because in the case that the array to be sorted is very large, as it was when I tested with a sample array of 55000 items, it would be able to sort the regions quickly. QuickSort would not take additional time to create variables such as temp in InsertionSort, iterate through the array to check for minimum or call out to other functions for every iteration as in SelectionSort, or loop over loops in addition to calling out to other functions as in BubbleSort. QuickSort seemed to me the most efficient way to move quickly through an array, starting from either end instead of just iterating from the beginning, and uses only one other constant time function swap(). It does not take additional time consuming measures to check and compare values as like the other in-place sorting algorithm mentioned. By beginning the comparisons and moving along from both the beginning and the end in addition to the recursion used to split the array, partition and QuickSort lose no time nor space to unnecessary conditions and calls, instead moving quickly to break down the array and check only what is important. In addition, I found that QuickSort was the most fitting algorithm to sort a specific subset as I had set the regions up to be in my algorithm. With some alterations, its algorithm worked the best with the way I had organized my regions to be sorted due to the way I could precisely pass in my region indeces int array and specify the indeces values as “lower” and “upper” in the partition algorithm.

- Is the algorithm you wrote faster, slower, or about the same as MergeSort?

In HybridSort, I attempted to compile a list of runs (sorted sections of array), regions (unsorted sections of array), sort only the unsorted regions using QuickSort, leaving a list of sorted runs of varied size. I then continuously merged adjacent runs using a merge function, updating the array and the runs list until there remained a list of a single run equating to the whole, final sorted list. 

The algorithm that I wrote is comparable to MergeSort when the array size is smaller, but is much slower as the array size increases. If I set my runSize to 20, I notice that when the array size is less than 500, the time to execute each HybridSort and MergeSort are about the same. However, beyond that, my HybridSort time becomes exponentially higher than the MergeSort time with each increase in array size. If I increase my runSize to be 200, 1000 or 5000, I notice that my runtime for HybridSort decreases as the runSize increases. For example, at an array size of 10,000 - a runSize of 5000 yields a runtime of 293 ms while a runSize of 500 yields a runtime of 859 ms. 

It would be said that a truly efficient algorithm would keep a fairly low, consistent runtime despite the arraysize growing by the thousands as MergeSort maintains. As my HybridSort increases significantly in correlation to the growth of the array size,  my algorithm is not sustainable nor truly efficient. While the algorithm works, it is not consistent in it's speed not it's execution. Its decrease in speed and tendency to get caught inside a loop every once in a few calls makes it less reliable and more time and space consuming, despite the actual intention to hybridize sorting algorithms to beat MergeSort's efficiency. This is likely due to the many iterations and comparisons done while attempting to construct a list of runs, then regions, then calling an in-place sorting algorithm to sort the regions, and then looping through a call to get more runs and merging until there is only one single run which is the sorted array. 

I utilized many for loops, to iterate through all of my lists - ArrayLists regions and runs, int arrays of all of the indeces of each region and run within the ArrayLists, an ArrayList totalRuns to collect the new runs after merging, in addition to the subset arrays leftArr and rightArr used in the merge function. To illustrate just a few of the algorithm complexities of individual functions, my getRuns function is O(n^2), my getRegions is O(n^5), my hybridSort is O(n^2 * runtime of getRuns * runtime of merge) = O(n^2 * n^2 * n^4 * n^6) = O(n^14). In its worst case, MergeSort is only O(n(logn)), which works faster compared to the estimated total runtime of overall class or individual function HybridSort. With the amount of comparisons, loops, and calls to external functions within functions implemented in HybridSort, it is understandable that the algorithm decreases in efficiency as the array size increases, despite how increasing runSize may offset some of the complexity. 
